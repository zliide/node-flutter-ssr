// Auto-generated by text-measure.html

interface Size {
    ascent: number
    descent: number
    width: number
}

type Metrics = {
    [family: string]: {
        [weight: string]: {
            default: Size
            individuals: {
                ascent: [letters: string, value: number][]
                descent: [letters: string, value: number][]
                width: [letters: string, value: number][]
            },
            ligatures: [Size, string][]
            spacing: {
                default: number,
                special: [texts: string[], value: number][]
            }
        }
    }
}

// tslint:disable-next-line: max-line-length quotemark
const metrics: Metrics = { "Roboto": { "normal": { "default": { "ascent": 0.7165, "descent": 0, "width": 0.5558 }, "individuals": { "ascent": [[" ", 0], ["0123689ĉéèê", 0.7188], ["5", 0.7054], ["7ñ", 0.7076], ["%/()?£€fßCGOQS", 0.7277], [",.", 0.1004], ["-", 0.3036], [";:uvwxyz", 0.5179], ["$", 0.7813], ["acçegmnopqrsæ", 0.5313], ["öü", 0.721], ["t", 0.6987], ["ø", 0.5513], ["å", 0.7411], ["Ĉ", 0.8929], ["Ñ", 0.8728], ["ÖÜ", 0.8594], ["Ø", 0.7433], ["Å", 0.8683]], "descent": [["05689/€abcĉdeéèêoösßuüæåCĈGJOÖSUÜ", 0.0112], ["3£", 0.0134], ["%", 0.0268], ["()gjy", 0.2098], [",;", 0.1406], ["-", -0.2143], ["$", 0.1027], ["ç", 0.1964], ["pq", 0.1987], ["t", 0.0067], ["ø", 0.0379], ["Q", 0.0558], ["Ø", 0.029]], "width": [[" !/,.;:ftI", 0.279], ["%æ", 0.8906], ["()-r", 0.3326], ["cçĉksvxyzJ", 0.5], ["ijl", 0.221], ["mM", 0.8326], ["ßøFTZ", 0.6094], ["wCĈDHNÑRUÜ", 0.721], ["ABEKPSVXYÅ", 0.6674], ["GOÖQØ", 0.779], ["W", 0.9442], ["Æ", 1]] }, "ligatures": [[{ "ascent": 0.3032, "descent": -0.2148, "width": 0.6116 }, " -"], [{ "ascent": 0.3032, "descent": -0.2148, "width": 0.6116 }, "- "]], "spacing": { "default": 0, "special": [[["11", "LT", "TA"], -0.0714], [["ff", "Av", "Aw", "Ay", "RT", "RV", "RW", "RY", "TO", "Vi", "W-", "W;", "W:", "We", "Wo", "Wr", "Wu"], -0.0179], [["r,", "r.", "w,", "w.", "FA", "T-", "Tw", "Ty", "V-", "Ve", "Vo", "Yu", "Yv"], -0.0536], [["v,", "v.", "y,", "y.", "AT", "AV", "AY", "LV", "LW", "LY", "PA", "Va", "VA", "Ya", "Yp", "YA"], -0.0759], [["AW", "V;", "V:", "WA"], -0.0402], [["F,", "F.", "T,", "T.", "T;", "T:"], -0.1116], [["Ly", "Ti", "Tr", "Tu", "Vr", "Vu", "Vy", "Wa", "Yi"], -0.0357], [["P,", "P.", "Y,", "Y."], -0.1295], [["Ta", "Tc", "Te", "To", "Ts"], -0.1071], [["V,", "V."], -0.0937], [["W,", "W.", "Y:"], -0.058], [["Wy"], -0.0089], [["Y-", "Ye", "Yo", "Yq"], -0.0893], [["Y;"], -0.067]] } } }, "MaterialIcons": { "normal": { "default": { "ascent": 0, "descent": 0, "width": 1 }, "individuals": { "ascent": [["", 0.8996]], "descent": [["", -0.1004]], "width": [] }, "ligatures": [[{ "ascent": 0.9004, "descent": -0.0996, "width": 2 }, " "], [{ "ascent": 0.9004, "descent": -0.0996, "width": 2 }, " "]], "spacing": { "default": 0, "special": [] } } } }

export function measureText(font: string, text: string) {
    return measureTextWithMetrics(metrics, font, text)
}

const fontRegExp = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])?))?\s*([-_,\"\/\sa-z]+?)\s*$/i

function parseFont(font: string) {
    const match = fontRegExp.exec(font)
    if (!match) {
        console.log('Unmatched font: ' + font)
        return { weight: 'normal', size: '12px', height: '1', family: 'sans-serif' }
    }
    const [_all, _style = 'normal', _variant = 'normal', weight = 'normal', size = '12px', height = '1', family] = match ?? []
    return { weight, size, height, family }
}

function getMetricsForFont(m: Metrics, font: string) {
    const { weight, size, family } = parseFont(font)
    if (!size.endsWith('px')) {
        console.warn('Font size not supported: ' + font)
    }
    const fm = m[family]?.[weight] ?? m[family]?.normal ?? Object.values(m[family] ?? Object.values(m)[0])[0]
    return {
        fontSize: parseFloat(size) || 12,
        metrics: fm,
    }
}

function measureTextWithMetrics(m: Metrics, font: string, text: string) {
    const fm = getMetricsForFont(m, font)
    const textSize = {
        width: 0,
        ascent: Number.MIN_SAFE_INTEGER,
        descent: Number.MIN_SAFE_INTEGER,
    }
    for (let i = 0; i !== text.length; ++i) {
        const letter = text[i]
        const letterSize = {
            ascent: fm.metrics.individuals.ascent.find(([letters]) => letters.includes(letter))?.[1] ?? fm.metrics.default.ascent,
            descent: fm.metrics.individuals.descent.find(([letters]) => letters.includes(letter))?.[1] ?? fm.metrics.default.descent,
            width: fm.metrics.individuals.width.find(([letters]) => letters.includes(letter))?.[1] ?? fm.metrics.default.width,
        }
        textSize.width += letterSize.width
        if (letterSize.ascent > textSize.ascent) {
            textSize.ascent = letterSize.ascent
        }
        if (letterSize.descent > textSize.descent) {
            textSize.descent = letterSize.descent
        }
    }
    for (let i = 0; i !== text.length - 1; ++i) {
        const pair = text.slice(i, i + 2)
        const spacing = fm.metrics.spacing.special.find(([texts]) => texts.includes(pair))?.[1] ?? fm.metrics.spacing.default
        textSize.width += spacing
    }
    return {
        height: (textSize.ascent + textSize.descent) * fm.fontSize,
        width: textSize.width * fm.fontSize,
        descent: textSize.descent * fm.fontSize,
    }
}
